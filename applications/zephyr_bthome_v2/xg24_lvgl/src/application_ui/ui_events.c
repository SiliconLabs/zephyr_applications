// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: BTHome v2_xG24_xG27_sensors_with_LVGL

#include "ui.h"
#include <zephyr/devicetree.h>
#include <zephyr/input/input_resistive_touchscreen_4wire.h>

static const struct device *touchscreen_dev = DEVICE_DT_GET(DT_ALIAS(touchscreen));

bool broadcast_enabled = false;
bool config_broadcast_interval = false;
bool config_device_name = false;
bool config_encryption_key = false;
uint16_t broadcast_interval = 2000;

static void lv_custom_event(lv_event_t * e);

void bthome_pressed_handle(lv_event_t * e)
{
  (void)e;
  lv_disp_load_scr(ui_SettingScreen);
}

void btn_back_callback(lv_event_t * e)
{
  (void)e;

  resistive_touchscreen_4wire_set_raw_data_cb(touchscreen_dev, NULL);
  lv_obj_remove_event_cb(ui_TSCalibrationScreen,
                         lv_custom_event);

  lv_disp_load_scr(ui_ApplicationScreen);
  config_broadcast_interval = false;
  config_device_name = false;
  config_encryption_key = false;
}

void swboardcast_enable_callback(lv_event_t * e)
{
  broadcast_enabled = (broadcast_enabled) ? false : true;
}

void keyboard_ready_callback(lv_event_t * e)
{
 (void)e;

 if (lv_keyboard_get_textarea(ui_Keyboard1) == ui_txtdevicename) {
     config_device_name = true;
 } else if (lv_keyboard_get_textarea(ui_Keyboard1) == ui_txtboardcastperiod) {
     config_broadcast_interval = true;
 } else if (lv_keyboard_get_textarea(ui_Keyboard1) == ui_txtencryptkey) {
     config_encryption_key = true;
 }
}


static void resistive_touchscreen_4wire_raw_data(const struct device *dev,
  int32_t point_x_value,
  int32_t point_y_value,
  float r_touch_value)
{
  static int32_t x_value_min = 0xffff, x_value_max = 0;
  static int32_t y_value_min = 0xffff, y_value_max = 0;
  static char str_value_x[32];
  static char str_value_y[32];
  static char str_x_min[32];
  static char str_y_min[32];
  static char str_x_max[32];
  static char str_y_max[32];
  static char str_rtouch[32];

  if (r_touch_value > 600) {
    // Touch is not detected
    return;
  }

  snprintf(str_value_x, sizeof(str_value_x), "X:                   %d", point_x_value);
  lv_label_set_text(ui_labelValueX, str_value_x);

  snprintf(str_value_y, sizeof(str_value_y), "Y:                   %d", point_y_value);
  lv_label_set_text(ui_labelValueY, str_value_y);

  if (x_value_min > point_x_value) {
    x_value_min = point_x_value;
  }
  snprintf(str_x_min, sizeof(str_x_min), "Xmin:           %d", x_value_min);
  lv_label_set_text(ui_labelValueXmin, str_x_min);

  if (x_value_max < point_x_value) {
    x_value_max = point_x_value;
  }
  snprintf(str_x_max, sizeof(str_x_max), "Xmax:           %d", x_value_max);
  lv_label_set_text(ui_labelValueXmax, str_x_max);

  if (y_value_min > point_y_value) {
    y_value_min = point_y_value;
  }
  snprintf(str_y_min, sizeof(str_y_min), "Ymin:           %d", y_value_min);
  lv_label_set_text(ui_labelValueYmin, str_y_min);

  if (y_value_max < point_y_value) {
    y_value_max = point_y_value;
  }
  snprintf(str_y_max, sizeof(str_y_max), "Ymax:           %d", y_value_max);
  lv_label_set_text(ui_labelValueYmax, str_y_max);

  snprintf(str_rtouch, sizeof(str_rtouch), "Rtouch:       %.2f", (double)r_touch_value);
  lv_label_set_text(ui_labelValueRTouch, str_rtouch);
}

static void lv_custom_event(lv_event_t * e)
{
  static char str_point_x[32];
  static char str_point_y[32];

  lv_event_code_t code = lv_event_get_code(e);
  lv_point_t p;

  if(code == LV_EVENT_PRESSED ||
     code == LV_EVENT_PRESSING ||
     code == LV_EVENT_PRESS_LOST) {
    lv_indev_t * indev = lv_event_get_indev(e);

    lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());
    if(indev_type == LV_INDEV_TYPE_POINTER || indev_type == LV_INDEV_TYPE_BUTTON) {
      /*Search the pressed area*/
      lv_indev_get_point(indev, &p);

      snprintf(str_point_x, sizeof(str_point_x), "PointX:        %d", p.x);
      lv_label_set_text(ui_labelPointX, str_point_x);
    
      snprintf(str_point_y, sizeof(str_point_y), "PointY:        %d", p.y);
      lv_label_set_text(ui_labelPointY, str_point_y);
    }
  }
}

void btlvgl_pressed_handle(lv_event_t * e)
{
  resistive_touchscreen_4wire_set_raw_data_cb(touchscreen_dev,
                                              resistive_touchscreen_4wire_raw_data);
	lv_disp_load_scr(ui_TSCalibrationScreen);
  lv_obj_add_event_cb(ui_TSCalibrationScreen,
                      lv_custom_event,
                      LV_EVENT_ALL,
                      NULL);
}